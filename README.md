## 정책 설정
- **포인트 충전에 대한 정책**
    - 충전할 포인트는 100 단위의 정수만 가능하다.
    - 최대 보유 포인트 금액은 1,000,000이다.
- **포인트 사용에 대한 정책**
    - 보유 포인트에서 사용할 포인트를 차감한 금액이 0보다 작으면 포인트를 사용할 수 없다.
- **포인트 내역 조회에 대한 정책**
    - 포인트 내역은 최신 순으로 정렬한다.
    - 타입으로는 충전(charge), 사용(use)가 있다.

---

## 동시성 제어 방식에 대한 분석

### 현 프로젝트에서 동시성 문제에 대한 정의
- 동시성 문제는 2개 이상의 스레드가 동시에 공유 자원에 접근할 때 발생할 수 있는 다양한 충돌 및 일관성 문제를 의미합니다.


- 동시성 제어는 이러한 문제를 방지하기 위해 여러 스레드가 자원을 안전하게 공유할 수 있도록 관리하는 기법입니다.


- 따라서 이 프로젝트에서는 동일한 사용자에 대한 포인트 충전/사용/조회에 대한 요청이 동시에 들어오면
  서로 같은 데이터에 접근하기 때문에 데이터 정합성에 대한 문제가 발생할 수 있기 때문에 이러한 상황이 동시성 문제에 해당합니다.


### 해결하고자 하는 것
1. **동일한 사용자에 대한 동시 요청의 순차적 처리**:
  동일한 사용자에 대해 동시에 여러 요청이 발생 할 경우, 이를 순차적으로 처리하여 한 번에 하나의 요청만 성공시켜야 합니다.


2. **서로 다른 사용자에 대한 동시 요청의 병렬 처리**: 
  서로 다른 사용자에 대해 동시에 여러 요청이 발생할 경우에는 서로 같은 자원에 접근하는게 아니므로 여러 스레드에서 병렬적으로 수행되어야 합니다.



### 동시성 제어 방식 선정
- 동시성 문제는 다양한 레벨에서 제어할 수 있습니다. 대표적으로는 다음 3가지 방식이 있습니다.
  - 애플리케이션 Lock
  - 데이터베이스 Lock
  - 분산 Lock(Redis 등)


- 접근 방식 선정
  - **애플리케이션 레벨에서 Lock**을 걸어 사용하는 방식으로 접근하였습니다.
  - 이유:
    - 현 프로젝트에서는 실제 DB를 연동하지 않음으로 데이터베이스 Lock 방식은 제외했습니다.
    - 큐를 이용한 Lock을 사용할 수도 있지만, 현 프로젝트는 분산환경이 아니기 때문에 큐를 사용하는 것은 오버스펙일 수 있기 때문에 큐를 사용한 방식도 제외하였습니다.


### 동시성 제어 구현

`ReentrantLock`과 `ConcurrentHashMap`을 조합하여 구현

1. 사용자 별 Lock 객체 생성: `ConcurrentHashMap` 활용
    - 사용자 별로 Lock을 관리함으로써 동일한 사용자에 대한 동시 요청의 순차적 처리를 보장


2. 동시성 제어 도구: `ReentrantLock` 사용
   - `ReentrantLock` 사용 이유:
     - `synchronized`와 달리 **Lock 획득 순서를 보장**합니다.   
        즉, 동일 사용자에 대한 요청이 동시에 여러 개 들어오는 경우 선입선출(FIFO) 처리가 가능합니다.   

     - 사용자별 Lock 객체를 관리하기 위해 `ConcurrentHashMap`을 함께 사용하는데 `synchronized`와 함께 사용시 장점을 활용하지 못합니다.   
       `ConcurrentHashMap`은 자체적으로 분리된 락(Striped Lock)을 사용하여 특정 키에만 락을 걸고 다른 키에 대한 작업은 병렬로 처리할 수 있는 구조인데,   
       만약 `synchronized` 블록이 넓은 범위를 포함하게 되면, 여러 키의 작업을 직렬화시켜 병렬 처리를 제한하기 때문입니다.
   
   - 참고) 자바에서 동시성 문제를 제어하기 위한 도구로 자주 사용되는 `synchronized`와 `ReentrantLock`를 비교

        |               | `synchronized`                            | `ReentrantLock`                                                        |
        |---------------|-------------------------------------------|------------------------------------------------------------------------|
        | 사용 편의성        | 간단하게 키워드를 통해 구현 가능                        | 명시적으로 락 획득 및 해제를 관리해야 함                                                |
        | 기능            | 기본적인 락 제공. 재진입 가능 (동일 스레드가 여러 번 획득 가능).   | 재진입 가능 및 다양한 기능 제공 (공정성 설정, 타임아웃, 상태 확인 등).                            |
        | 락 해제 제어       | JVM이 자동으로 관리                              | unlock()을 통해 명시적으로 해제 가능                                               |
        | 락 획득 순서 보장    | 보장하지 않음                                   | 공정 모드 설정 시 대기 중인 스레드가 락을 얻는 순서 보장                                      |
        | 적합성           | 간단한 동기화가 필요한 경우에 적합                       | 락 획득 순서를 제어해야 하거나 타임아웃, 상태 확인, 조건 변수(Condition) 등이 필요한 고급 동기화가 요구되는 경우 |



### 테스트 시나리오
0. 동시 요청 환경을 위해 `ExecutorService`를 사용하여 여러 스레드를 생성하여 테스트합니다.
1. 동일한 사용자에 대한 동시 요청의 순차적 처리 검증
   - 동일한 사용자에 대해 10개의 포인트 충전 또는 사용 요청을 동시에 여러 스레드에서 처리하게 하고,   
     각 사용자별로 요청이 순차적으로 처리되는지 확인합니다.
   - 동일한 사용자에 대해 포인트 충전, 포인트 사용, 포인트 조회 요청을 동시에 여러 스레드에서 처리하게 하고,  
     각 사용자별로 요청이 순차적으로 처리되는지 확인합니다.
2. 서로 다른 사용자에 대한 동시 요청의 병렬 처리 검증
   - 10명의 사용자에 대해 각각 10개의 포인트 충전 또는 사용 요청을 동시에 여러 스레드에서 처리하게 하고, 
     각 사용자별로 요청이 병렬적으로 처리되는지 확인합니다.
